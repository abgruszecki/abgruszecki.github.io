[{"authors":null,"categories":null,"content":" I‚Äôm interested in building strong theoretical foundations for pragmatic PL features. During my PhD in Martin Odersky‚Äôs lab I focused on the theory of Capture Tracking for Scala. Also, I worked on SuperF, a type inference algorithm for System F and added subtyping reconstruction, a novel OO take on GADTs, to the Scala compiler.\nDeveloping some very desireable PL features, like type inference, requires taking on additional complexity to improve the life of the language‚Äôs users. After a certain point, the only way to implement such features without completely losing track of what‚Äôs going on involves developing and studying appropriate formal foundations.\nI‚Äôm also interested in:\npersonal knowledge management interactive programming environments education If you see how all three are connected, let‚Äôs chat :)\n","date":1704412800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1704412800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I‚Äôm interested in building strong theoretical foundations for pragmatic PL features. During my PhD in Martin Odersky‚Äôs lab I focused on the theory of Capture Tracking for Scala. Also, I worked on SuperF, a type inference algorithm for System F and added subtyping reconstruction, a novel OO take on GADTs, to the Scala compiler.","tags":null,"title":"Aleks Boruch‚Å†-‚Å†Gruszecki","type":"authors"},{"authors":[],"categories":[],"content":"Capture Tracking is an approach to tracking the capture of capabilities in types, which has been the subject of a long collaboration with Martin Odersky, Jonathan Brachth√§user, Ond≈ôej Lhot√°k, and Edward Lee, and to which a number of other people have contributed.\nThe foundational formal system for the approach is CC\u0026lt;:‚óª, published in TOPLAS. Its algorithmic aspects are discussed in a technical report.\nMartin Odersky‚Äôs Caprese project is focused on investigating these formal foundations further and developing their applications. The particular questions include (1) How to solve the ‚Äúwhat color is your function‚Äù problem when mixing synchronous and asynchronous programming? (2) How to express effect polymorphism without creating boilerplate? (3) How to combine manual and automatic memory management? (4) How to express high-level concurrency and parallelism, safely? (5) How to migrate large existing code bases to the new system? Find out in the slide deck here.\nCC\u0026lt;:‚óª is neither the first nor the last formalism for Capture Tracking. I discuss the developments that led to CC\u0026lt;:‚óª in my dissertation on the ‚ÄúFormal Foundations of Capture Tracking‚Äù, which I‚Äôll be defending privately on 25th of January, 2024. I‚Äôll be happy to send you a preprint via email, otherwise I‚Äôll publish the final version and link it here not too long after the defense. (Fingers crossed!)\nCapture Tracking is particularly focused on usability and ergonomics, so naturally there is an implementation, developed to a significant extent by Martin Odersky. You can find out more on this page.\nWork progresses on developing CC\u0026lt;:‚óª further. A formal system which enriches it with safe concurrency (by tracking separation of capabilities) was conditionally accepted for OOPSLA 2024. Find the preprint here.\nThere is also ongoing work on using the Capture Tracking implementation to develop a base library for async computation in direct style. A ‚Äústrawman‚Äù version of this library is available in a Github repository here.\n","date":1705340417,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1705340417,"objectID":"2fe603c91c919471dad69f45be9a4f76","permalink":"https://abgruszecki.ghpages.io/project/capture-tracking/","publishdate":"2024-01-15T17:40:17Z","relpermalink":"/project/capture-tracking/","section":"project","summary":"Tracking the Capture of capabilities in types.","tags":[],"title":"Capture Tracking","type":"project"},{"authors":["Lionel Parreaux","Aleks Boruch‚Å†-‚Å†Gruszecki","Andong Fan","Chun Yin Chau"],"categories":null,"content":"","date":1704412800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704412800,"objectID":"ee415f51d23a17cb3b72bef5e4fffe25","permalink":"https://abgruszecki.ghpages.io/publication/when-subtyping-constraints-liberate/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/when-subtyping-constraints-liberate/","section":"publication","summary":"Type inference in the presence of  first-class or ‚Äúimpredicative‚Äù second-order polymorphism √† la System F has been an active research area for several decades, with original works dating back to the end of the 80s. Yet, until now many basic problems remain open, such as how to type check expressions like (ùúÜùë•. (ùë• 123, ùë• True)) id reliably. We show that a type inference approach based on multi-bounded polymorphism, a form of implicit polymorphic subtyping with multiple lower and upper bounds, can help us resolve most of these problems in a uniquely simple and regular way. We define F{‚â§}, a declarative type system derived  from the existing theory of implicit coercions by Cretin and R√©my (LICS 2014), and we introduce SuperF,  a novel algorithm to infer polymorphic multi-bounded F{‚â§} types while checking user type annotations written in the syntax of System F. We use a recursion-avoiding heuristic to guarantee  termination of type inference at the cost of rejecting some valid programs, which thankfully rarely triggers in practice. We show that SuperF is vastly more powerful than all first-class-polymorphic type inference systems proposed so far, significantly advancing the state of the art in  type inference for general-purpose programming languages.","tags":[],"title":"When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism","type":"publication"},{"authors":["Aleks Boruch‚Å†-‚Å†Gruszecki","Martin Odersky","Edward Lee","Ond≈ôej Lhot√°k","Jonathan Brachth√§user"],"categories":null,"content":"","date":1694563200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1694563200,"objectID":"e58aca81384fbca53b36ec23a8242eab","permalink":"https://abgruszecki.ghpages.io/publication/capturing-types/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/capturing-types/","section":"publication","summary":"Type systems usually characterize the shape of values but not their free variables. However, many desirable safety properties could be guaranteed if one knew the free variables captured by values. We describe ùñ¢ùñ¢\u003c:‚óª, a calculus where such captured variables are succinctly represented in types, and show it can be used to safely implement effects and effect polymorphism via scoped capabilities. We discuss how the decision to track captured variables guides key aspects of the calculus, and show that ùñ¢ùñ¢\u003c:‚óª admits simple and intuitive types for common data structures and their typical usage patterns. We demonstrate how these ideas can be used to guide the implementation of capture checking in a practical programming language.","tags":[],"title":"Capturing Types","type":"publication"},{"authors":["Aleks Boruch‚Å†-‚Å†Gruszecki","Rados≈Çaw Wa≈õko","Yichen Xu","Lionel Parreaux"],"categories":null,"content":"","date":1657411200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657411200,"objectID":"8293f736918a459791143eb9cc6b5412","permalink":"https://abgruszecki.ghpages.io/publication/case-for-dot/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/case-for-dot/","section":"publication","summary":"Many programming languages in the OO tradition now support pattern matching in some form. Historical examples include Scala and Ceylon, with the more recent additions of Java, Kotlin, TypeScript, and Flow. But pattern matching on generic class hierarchies currently results in puzzling type errors in most of these languages. Yet this combination of features occurs naturally in many scenarios, such as when manipulating typed ASTs. To support it properly, compilers needs to implement a form of subtyping reconstruction: the ability to reconstruct subtyping information uncovered at runtime during pattern matching. We introduce cDOT, a new calculus in the family of Dependent Object Types (DOT) intended to serve as a formal foundation for subtyping reconstruction. Being descended from pDOT, itself a formal foundation for Scala, cDOT can be used to encode advanced object-oriented features such as generic inheritance, type constructor variance, F-bounded polymorphism, and first-class recursive modules. We demonstrate that subtyping reconstruction subsumes GADTs by encoding $\\lambda_{2,G\\mu}$, a classical constraint-based GADT calculus, into cDOT.","tags":[],"title":"A case for DOT: Theoretical Foundations for Objects with Pattern Matching and GADT-style Reasoning","type":"publication"},{"authors":["Jonathan Brachth√§user","Philipp Schuster","Edward Lee","Aleks Boruch‚Å†-‚Å†Gruszecki"],"categories":null,"content":"","date":1651190400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1651190400,"objectID":"f9856b53e48d9f6e76efcc0636fce993","permalink":"https://abgruszecki.ghpages.io/publication/eff-cap-box/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/eff-cap-box/","section":"publication","summary":"Reasoning about the use of external resources is an important aspect of many practical applications. Effect systems enable tracking such information in types, but at the cost of complicating signatures of common functions. Capabilities coupled with escape analysis offer safety and natural signatures, but are often overly coarse grained and restrictive. We present System C, which builds on and generalizes ideas from type-based escape analysis  and demonstrates that capabilities and effects can be reconciled harmoniously. By assuming that all functions are second class, we can admit natural signatures for many common programs. By introducing a notion of boxed values, we can lift the restrictions of second-class values at the cost of needing to track degree-of-impurity information in types. The system we present is expressive enough to support effect handlers in full capacity. We practically evaluate System C in an implementation and prove its soundness.","tags":[],"title":"Effects, capabilities, and boxes: from scope-based reasoning to type-based reasoning and back","type":"publication"}]