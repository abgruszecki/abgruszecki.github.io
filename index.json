[{"authors":null,"categories":null,"content":" I think AI-based tools are the future of software development, and I‚Äôm investigating how our understanding of programming languages can help us build that future.\nCurrently a postdoc in Arjun Guha‚Äôs group at the Northeastern University.\nIn a previous life, I was interested in building strong theoretical foundations for pragmatic programming language features. During my PhD in Martin Odersky‚Äôs lab my main focus was on the theory of Capture Tracking for Scala. Also, I worked on SuperF, a type inference algorithm for System F and added subtyping reconstruction, a novel object-oriented take on GADTs, to the Scala compiler.\n","date":1704412800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1704412800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I think AI-based tools are the future of software development, and I‚Äôm investigating how our understanding of programming languages can help us build that future.\nCurrently a postdoc in Arjun Guha‚Äôs group at the Northeastern University.","tags":null,"title":"Alex Boruch‚Å†-‚Å†Gruszecki","type":"authors"},{"authors":[],"categories":[],"content":"Capture Tracking is an approach to tracking the capture of capabilities in types, which has been the subject of a long collaboration with Martin Odersky, Jonathan Brachth√§user, Ond≈ôej Lhot√°k, and Edward Lee, and to which a number of other people have contributed.\nThe foundational formal system for the approach is CC\u0026lt;:‚óª, published in TOPLAS. Its algorithmic aspects are discussed in a technical report.\nMartin Odersky‚Äôs Caprese project is focused on investigating these formal foundations further and developing their applications. The particular questions include (1) How to solve the ‚Äúwhat color is your function‚Äù problem when mixing synchronous and asynchronous programming? (2) How to express effect polymorphism without creating boilerplate? (3) How to combine manual and automatic memory management? (4) How to express high-level concurrency and parallelism, safely? (5) How to migrate large existing code bases to the new system? Find out in the slide deck here.\nCC\u0026lt;:‚óª is neither the first nor the last formalism for Capture Tracking. I discuss the developments that led to CC\u0026lt;:‚óª in my dissertation on the ‚ÄúFormal Foundations of Capture Tracking‚Äù.\nCapture Tracking is particularly focused on usability and ergonomics, so naturally there is an implementation, developed to first and foremost by Martin Odersky. You can find out more on this page.\nWork progresses on developing CC\u0026lt;:‚óª further. A formal system which enriches it with safe concurrency (by tracking separation of capabilities) was conditionally accepted for OOPSLA 2024. Find the preprint here.\nThere is also ongoing work on using the Capture Tracking implementation to develop a base library for async computation in direct style. A ‚Äústrawman‚Äù version of this library is available in a Github repository here.\n","date":1705340417,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1705340417,"objectID":"2fe603c91c919471dad69f45be9a4f76","permalink":"https://abgru.me/project/capture-tracking/","publishdate":"2024-01-15T17:40:17Z","relpermalink":"/project/capture-tracking/","section":"project","summary":"Tracking the Capture of capabilities in types.","tags":[],"title":"Capture Tracking","type":"project"},{"authors":["Alex Boruch‚Å†-‚Å†Gruszecki","Adrien Ghosn","Mathias Payer","Cl√©ment Pit-Claudel"],"categories":null,"content":"","date":1704412800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704412800,"objectID":"d428d5e67f0a1dafb3102956f278ffdf","permalink":"https://abgru.me/publication/gradient/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/gradient/","section":"publication","summary":"Modern software needs fine-grained compartmentalization, i.e., intra-process isolation. A particularly important reason for it are supply-chain attacks, the need for which is aggravated by modern applications depending on hundreds or even thousands of libraries. Object capabilities are a particularly salient approach to compartmentalization, but they require the entire program to assume a lack of ambient authority. Most of existing code was written under no such assumption; effectively, existing applications need to undergo a rewrite-the-world migration to reap the advantages of ocap. We propose gradual compartmentalization, an approach which allows gradually migrating an application to object capabilities, component by component in arbitrary order, all the while continuously enjoying security guarantees. The approach relies on runtime authority enforcement and tracking the authority of objects the type system. We present Gradient, a proof-of-concept gradual compartmentalization extension to Scala which uses Enclosures and Capture Tracking as its key components. We evaluate our proposal by migrating the standard XML library of Scala to Gradient.","tags":[],"title":"Gradient: Gradual Compartmentalization via Object Capabilities Tracked in Types","type":"publication"},{"authors":["Lionel Parreaux","Alex Boruch‚Å†-‚Å†Gruszecki","Andong Fan","Chun Yin Chau"],"categories":null,"content":"","date":1704412800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704412800,"objectID":"ee415f51d23a17cb3b72bef5e4fffe25","permalink":"https://abgru.me/publication/when-subtyping-constraints-liberate/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/when-subtyping-constraints-liberate/","section":"publication","summary":"Type inference in the presence of  first-class or ‚Äúimpredicative‚Äù second-order polymorphism √† la System F has been an active research area for several decades, with original works dating back to the end of the 80s. Yet, until now many basic problems remain open, such as how to type check expressions like (ùúÜùë•. (ùë• 123, ùë• True)) id reliably. We show that a type inference approach based on multi-bounded polymorphism, a form of implicit polymorphic subtyping with multiple lower and upper bounds, can help us resolve most of these problems in a uniquely simple and regular way. We define F{‚â§}, a declarative type system derived  from the existing theory of implicit coercions by Cretin and R√©my (LICS 2014), and we introduce SuperF,  a novel algorithm to infer polymorphic multi-bounded F{‚â§} types while checking user type annotations written in the syntax of System F. We use a recursion-avoiding heuristic to guarantee  termination of type inference at the cost of rejecting some valid programs, which thankfully rarely triggers in practice. We show that SuperF is vastly more powerful than all first-class-polymorphic type inference systems proposed so far, significantly advancing the state of the art in  type inference for general-purpose programming languages.","tags":[],"title":"When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism","type":"publication"},{"authors":["Alex Boruch‚Å†-‚Å†Gruszecki","Martin Odersky","Edward Lee","Ond≈ôej Lhot√°k","Jonathan Brachth√§user"],"categories":null,"content":"","date":1694563200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1694563200,"objectID":"e58aca81384fbca53b36ec23a8242eab","permalink":"https://abgru.me/publication/capturing-types/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/capturing-types/","section":"publication","summary":"Type systems usually characterize the shape of values but not their free variables. However, many desirable safety properties could be guaranteed if one knew the free variables captured by values. We describe ùñ¢ùñ¢\u003c:‚óª, a calculus where such captured variables are succinctly represented in types, and show it can be used to safely implement effects and effect polymorphism via scoped capabilities. We discuss how the decision to track captured variables guides key aspects of the calculus, and show that ùñ¢ùñ¢\u003c:‚óª admits simple and intuitive types for common data structures and their typical usage patterns. We demonstrate how these ideas can be used to guide the implementation of capture checking in a practical programming language.","tags":[],"title":"Capturing Types","type":"publication"},{"authors":["Alex Boruch‚Å†-‚Å†Gruszecki","Rados≈Çaw Wa≈õko","Yichen Xu","Lionel Parreaux"],"categories":null,"content":"","date":1657411200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657411200,"objectID":"8293f736918a459791143eb9cc6b5412","permalink":"https://abgru.me/publication/case-for-dot/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/case-for-dot/","section":"publication","summary":"Many programming languages in the OO tradition now support pattern matching in some form. Historical examples include Scala and Ceylon, with the more recent additions of Java, Kotlin, TypeScript, and Flow. But pattern matching on generic class hierarchies currently results in puzzling type errors in most of these languages. Yet this combination of features occurs naturally in many scenarios, such as when manipulating typed ASTs. To support it properly, compilers needs to implement a form of subtyping reconstruction: the ability to reconstruct subtyping information uncovered at runtime during pattern matching. We introduce cDOT, a new calculus in the family of Dependent Object Types (DOT) intended to serve as a formal foundation for subtyping reconstruction. Being descended from pDOT, itself a formal foundation for Scala, cDOT can be used to encode advanced object-oriented features such as generic inheritance, type constructor variance, F-bounded polymorphism, and first-class recursive modules. We demonstrate that subtyping reconstruction subsumes GADTs by encoding $\\lambda_{2,G\\mu}$, a classical constraint-based GADT calculus, into cDOT.","tags":[],"title":"A case for DOT: Theoretical Foundations for Objects with Pattern Matching and GADT-style Reasoning","type":"publication"},{"authors":["Jonathan Brachth√§user","Philipp Schuster","Edward Lee","Alex Boruch‚Å†-‚Å†Gruszecki"],"categories":null,"content":"","date":1651190400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1651190400,"objectID":"f9856b53e48d9f6e76efcc0636fce993","permalink":"https://abgru.me/publication/eff-cap-box/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/eff-cap-box/","section":"publication","summary":"Reasoning about the use of external resources is an important aspect of many practical applications. Effect systems enable tracking such information in types, but at the cost of complicating signatures of common functions. Capabilities coupled with escape analysis offer safety and natural signatures, but are often overly coarse grained and restrictive. We present System C, which builds on and generalizes ideas from type-based escape analysis  and demonstrates that capabilities and effects can be reconciled harmoniously. By assuming that all functions are second class, we can admit natural signatures for many common programs. By introducing a notion of boxed values, we can lift the restrictions of second-class values at the cost of needing to track degree-of-impurity information in types. The system we present is expressive enough to support effect handlers in full capacity. We practically evaluate System C in an implementation and prove its soundness.","tags":[],"title":"Effects, capabilities, and boxes: from scope-based reasoning to type-based reasoning and back","type":"publication"}]