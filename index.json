[{"authors":null,"categories":null,"content":" I think AI-based tools are the future of software development, and I‚Äôm investigating how our understanding of programming languages can help us build that future.\nCurrently a postdoc in Arjun Guha‚Äôs group at the Northeastern University.\nIn a previous life, I was interested in building strong theoretical foundations for pragmatic programming language features. During my PhD in Martin Odersky‚Äôs lab my main focus was on the theory of Capture Tracking for Scala. Also, I worked on SuperF, a type inference algorithm for System F and added subtyping reconstruction, a novel object-oriented take on GADTs, to the Scala compiler.\n","date":1704412800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1704412800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I think AI-based tools are the future of software development, and I‚Äôm investigating how our understanding of programming languages can help us build that future.\nCurrently a postdoc in Arjun Guha‚Äôs group at the Northeastern University.","tags":null,"title":"Alex Boruch‚Å†-‚Å†Gruszecki","type":"authors"},{"authors":[],"categories":[],"content":"Agnostics (accepted at ICLR 2026) is a collaboration with Yangtian Zi, Zixuan Wu, Tejas Oberoi, Carolyn Jane Anderson, Joydeep Biswas, and Arjun Guha.\nLLMs excel at programming languages like Python and JavaScript, yet stumble on low-resource languages essential to science and engineering. Post-training the models is a bottleneck: every new language seems to require new data, new tests, and more reinforcement learning infrastructure.\nWe show how to turn an existing dataset of coding problems into a reinforcement learning environment which can be adapted to any programming language. Our approach turns Qwen 3 4B and 8B into SOTA ‚â§16B models for low-resource programming languages, rivaling much larger models, including their 32B sibling. And when we trained Qwen 3 4B on very low-resource programming languages, the comparison wasn‚Äôt even fair. (We‚Äôre comparing them on our multi-language version of LiveCodeBench, which we‚Äôre releasing together with the report!)\nLinks The ICLR paper is available here.\nThe ArXiv report is available here.\nOur trained models are available here.\nThe script for evaluating models on Ag-LiveCodeBench-X can be found here. The dataset is available here, and our verifiers are available here.\nWe will release our training framework very soon!\nBrief overview Our key novel idea is to judge code only by its externally observable behavior (e.g., I/O). Some datasets are already in such a format, many others can be rewritten to it. We can write a universal verifier for such problems, which lets us teach a model any programming language. One universal verifier + a tiny per-language YAML file = reinforcement learning that works everywhere.\n(1) We use an LLM to reformulate language-specific datasets into our standard language-agnostic format. (2) We generate prompts and a configured verifier targeting a particular language, with a small (often 4-line!) configuration. (3) We apply reinforcement learning with verified rewards (RLVR) using a robust, language-agnostic execution sandbox that we develop. (4) The result is a model specialized to the target language.\nOur approach particularly excels at finetuning models for low-resource languages, since it does not rely on language-specific high-quality datasets.\nAn analysis of the generated programs shows that the trained models make fewer syntax and API mistakes. The models have learned the simpler rules of the language, which also reveals the algorithmic mistakes they make. Find out more by reading the paper here!\n","date":1754438400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1754524800,"objectID":"5efbc01a893e1fe895d65aa9e4509cb8","permalink":"https://abgru.me/project/agnostics/","publishdate":"2025-08-06T00:00:00Z","relpermalink":"/project/agnostics/","section":"project","summary":"Reinforcing coding in any programming language.","tags":[],"title":"Agnostics","type":"project"},{"authors":[],"categories":[],"content":"Capture Tracking uses object capabilities tracked in types to unify effect and resource ownership systems. It was the main topic of my PhD and a subject of a long collaboration with Martin Odersky, Jonathan Brachth√§user, Ond≈ôej Lhot√°k, and Edward Lee. A number of other people have contributed to the project, including Yichen Xu and Oliver Braƒçevac.\nI‚Äôm no longer directly involved in the effort. For more up-to-date information, try the Capture Checking website. Oliver Braƒçevac‚Äôs Scala Days 2025 presentation also shows a number of more recent developments in detail.\nMy contributions, presented in my thesis, were centered around the formal foundations for the approach. The foundational formal system I was involved with is CC\u0026lt;:‚óª, published in TOPLAS 2023. My thesis also discusses other developments which led to CC\u0026lt;:‚óª.\nI also proposed Gradient, a Scala extension for gradually securing and compartmentalizing existing applications via object capabilities tracked in types. The associated paper was published at OOPSLA 2024; the OOPSLA presentation gives an accessible overview.\nAn algorithmic version of CC\u0026lt;:‚óª is discussed in a technical report.\nBy the time I wrote my thesis, the Scala implementation was developed first and foremost by Martin Odersky. See the official documentation here.\nThe implementation was extended with a number of features since my thesis, which led to System Capless, an updated formal foundation for the system published at OOPSLA 2025.\nSystem Capybara extends Capture Tracking with safe concurrency features, as presented on its project page. A formal system from which System Capybara evolved was published at OOPSLA 2024.\nGears is an ongoing project to extend Scala with structured async computation in direct style, with one-shot continuations as a primitive. See the project website here.\nMartin Odersky‚Äôs ongoing Caprese project aims to further develop both the formal foundations and the practical applications of Capture Tracking. The particular questions include (1) How to solve the ‚Äúwhat color is your function‚Äù problem when mixing synchronous and asynchronous programming? (2) How to express effect polymorphism without creating boilerplate? (3) How to combine manual and automatic memory management? (4) How to express high-level concurrency and parallelism, safely? (5) How to migrate large existing code bases to the new system? See the slide deck here.\n","date":1705340417,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1760572800,"objectID":"2fe603c91c919471dad69f45be9a4f76","permalink":"https://abgru.me/project/capture-tracking/","publishdate":"2024-01-15T17:40:17Z","relpermalink":"/project/capture-tracking/","section":"project","summary":"Tracking the Capture of capabilities in types.","tags":[],"title":"Capture Tracking","type":"project"},{"authors":["Alex Boruch‚Å†-‚Å†Gruszecki","Adrien Ghosn","Mathias Payer","Cl√©ment Pit-Claudel"],"categories":null,"content":"","date":1704412800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704412800,"objectID":"d428d5e67f0a1dafb3102956f278ffdf","permalink":"https://abgru.me/publication/gradient/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/gradient/","section":"publication","summary":"Modern software needs fine-grained compartmentalization, i.e., intra-process isolation. A particularly important reason for it are supply-chain attacks, the need for which is aggravated by modern applications depending on hundreds or even thousands of libraries. Object capabilities are a particularly salient approach to compartmentalization, but they require the entire program to assume a lack of ambient authority. Most of existing code was written under no such assumption; effectively, existing applications need to undergo a rewrite-the-world migration to reap the advantages of ocap. We propose gradual compartmentalization, an approach which allows gradually migrating an application to object capabilities, component by component in arbitrary order, all the while continuously enjoying security guarantees. The approach relies on runtime authority enforcement and tracking the authority of objects the type system. We present Gradient, a proof-of-concept gradual compartmentalization extension to Scala which uses Enclosures and Capture Tracking as its key components. We evaluate our proposal by migrating the standard XML library of Scala to Gradient.","tags":[],"title":"Gradient: Gradual Compartmentalization via Object Capabilities Tracked in Types","type":"publication"},{"authors":["Lionel Parreaux","Alex Boruch‚Å†-‚Å†Gruszecki","Andong Fan","Chun Yin Chau"],"categories":null,"content":"","date":1704412800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1704412800,"objectID":"ee415f51d23a17cb3b72bef5e4fffe25","permalink":"https://abgru.me/publication/when-subtyping-constraints-liberate/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/when-subtyping-constraints-liberate/","section":"publication","summary":"Type inference in the presence of  first-class or ‚Äúimpredicative‚Äù second-order polymorphism √† la System F has been an active research area for several decades, with original works dating back to the end of the 80s. Yet, until now many basic problems remain open, such as how to type check expressions like (ùúÜùë•. (ùë• 123, ùë• True)) id reliably. We show that a type inference approach based on multi-bounded polymorphism, a form of implicit polymorphic subtyping with multiple lower and upper bounds, can help us resolve most of these problems in a uniquely simple and regular way. We define F{‚â§}, a declarative type system derived  from the existing theory of implicit coercions by Cretin and R√©my (LICS 2014), and we introduce SuperF,  a novel algorithm to infer polymorphic multi-bounded F{‚â§} types while checking user type annotations written in the syntax of System F. We use a recursion-avoiding heuristic to guarantee  termination of type inference at the cost of rejecting some valid programs, which thankfully rarely triggers in practice. We show that SuperF is vastly more powerful than all first-class-polymorphic type inference systems proposed so far, significantly advancing the state of the art in  type inference for general-purpose programming languages.","tags":[],"title":"When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism","type":"publication"},{"authors":["Alex Boruch‚Å†-‚Å†Gruszecki","Martin Odersky","Edward Lee","Ond≈ôej Lhot√°k","Jonathan Brachth√§user"],"categories":null,"content":"","date":1694563200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1694563200,"objectID":"e58aca81384fbca53b36ec23a8242eab","permalink":"https://abgru.me/publication/capturing-types/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/capturing-types/","section":"publication","summary":"Type systems usually characterize the shape of values but not their free variables. However, many desirable safety properties could be guaranteed if one knew the free variables captured by values. We describe ùñ¢ùñ¢\u003c:‚óª, a calculus where such captured variables are succinctly represented in types, and show it can be used to safely implement effects and effect polymorphism via scoped capabilities. We discuss how the decision to track captured variables guides key aspects of the calculus, and show that ùñ¢ùñ¢\u003c:‚óª admits simple and intuitive types for common data structures and their typical usage patterns. We demonstrate how these ideas can be used to guide the implementation of capture checking in a practical programming language.","tags":[],"title":"Capturing Types","type":"publication"},{"authors":["Alex Boruch‚Å†-‚Å†Gruszecki","Rados≈Çaw Wa≈õko","Yichen Xu","Lionel Parreaux"],"categories":null,"content":"","date":1657411200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657411200,"objectID":"8293f736918a459791143eb9cc6b5412","permalink":"https://abgru.me/publication/case-for-dot/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/case-for-dot/","section":"publication","summary":"Many programming languages in the OO tradition now support pattern matching in some form. Historical examples include Scala and Ceylon, with the more recent additions of Java, Kotlin, TypeScript, and Flow. But pattern matching on generic class hierarchies currently results in puzzling type errors in most of these languages. Yet this combination of features occurs naturally in many scenarios, such as when manipulating typed ASTs. To support it properly, compilers needs to implement a form of subtyping reconstruction: the ability to reconstruct subtyping information uncovered at runtime during pattern matching. We introduce cDOT, a new calculus in the family of Dependent Object Types (DOT) intended to serve as a formal foundation for subtyping reconstruction. Being descended from pDOT, itself a formal foundation for Scala, cDOT can be used to encode advanced object-oriented features such as generic inheritance, type constructor variance, F-bounded polymorphism, and first-class recursive modules. We demonstrate that subtyping reconstruction subsumes GADTs by encoding $\\lambda_{2,G\\mu}$, a classical constraint-based GADT calculus, into cDOT.","tags":[],"title":"A case for DOT: Theoretical Foundations for Objects with Pattern Matching and GADT-style Reasoning","type":"publication"},{"authors":["Jonathan Brachth√§user","Philipp Schuster","Edward Lee","Alex Boruch‚Å†-‚Å†Gruszecki"],"categories":null,"content":"","date":1651190400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1651190400,"objectID":"f9856b53e48d9f6e76efcc0636fce993","permalink":"https://abgru.me/publication/eff-cap-box/","publishdate":"2000-01-01T00:00:00Z","relpermalink":"/publication/eff-cap-box/","section":"publication","summary":"Reasoning about the use of external resources is an important aspect of many practical applications. Effect systems enable tracking such information in types, but at the cost of complicating signatures of common functions. Capabilities coupled with escape analysis offer safety and natural signatures, but are often overly coarse grained and restrictive. We present System C, which builds on and generalizes ideas from type-based escape analysis  and demonstrates that capabilities and effects can be reconciled harmoniously. By assuming that all functions are second class, we can admit natural signatures for many common programs. By introducing a notion of boxed values, we can lift the restrictions of second-class values at the cost of needing to track degree-of-impurity information in types. The system we present is expressive enough to support effect handlers in full capacity. We practically evaluate System C in an implementation and prove its soundness.","tags":[],"title":"Effects, capabilities, and boxes: from scope-based reasoning to type-based reasoning and back","type":"publication"}]